# Power user fundamentals

Power user is a computer user who uses more advanced features of computer hardware, operating systems, programs, or web sites than the average user.

It basically means that you need to know what you are doing. You need to know how a computer works and which tools are the most efficient to achieve your goal.

## How does the computer work?

[Personal computer](https://en.wikipedia.org/wiki/Personal_computer) can have many forms.

Understanding to [Linux Kernel](https://docs.huihoo.com/linux/kernel/a1/index.html) will give you the knowhow and [Bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) will let you rule by mighty [commands](https://en.wikipedia.org/wiki/List_of_Unix_commands).


## Linux vs Windows

[Linux](https://en.wikipedia.org/wiki/Linux) rules IT Business and Windows rules [desktops](https://en.wikipedia.org/wiki/Desktop_computer). Most likely all your work will end up on Linux server. The best is to have scripts that you can run without problems in any operating system. My favourite choice is Bash.

### Bash in Linux

Linux usually already has all important tools installed by default.

[Midnight Commander](https://en.wikipedia.org/wiki/Midnight_Commander) can run in terminal.
[Double Commander](https://en.wikipedia.org/wiki/Double_Commander) is great clone of Total Commander.

### Bash in Windows

Download Git for Windows [here](https://git-scm.com/download/win)

Don't forget to check option for experimental winpty during installation so you don't need to type winpty with every command.

Once installed you should be ready to use Git, GitBash and Bashrc.
You need to install a terminal that can support bash to be able to use bash and bashrc.

[ConEmu](https://conemu.github.io) is a great terminal for windows.

For those who don't like Windows explorer and don't want to feel like a master clicker, I strongly recommend [Total Commander](https://www.ghisler.com).

### Visual Studio Code bash configuration

Edit file C:\Users\Username\AppData\Roaming\Code\User\settings.json like this:

    {
        "terminal.integrated.profiles.windows": {
            "PowerShell": {
                "source": "PowerShell",
                "icon": "terminal-powershell"
            },
            "CommandPrompt": {
                "path": [
                    "${env:windir}\\Sysnative\\cmd.exe",
                    "${env:windir}\\System32\\cmd.exe"
                ],
                "args": [],
                "icon": "terminal-cmd"
            },
            "GitBash": {
                "path": ["c:\\MyProgramFiles\\Git\\bin\\bash.exe"],
                "args": [],
                "icon": "terminal-bash"
            }
        },
        "terminal.integrated.defaultProfile.windows": "GitBash",
        "editor.fontSize": 17,
        "window.zoomLevel": 0.4,
        "typescript.updateImportsOnFileMove.enabled": "always"
    }

## Bashrc

Create .bash_profile and add there

    # generated by Git for Windows
    test -f ~/.profile && . ~/.profile
    test -f ~/.bashrc && . ~/.bashrc
    PROMPT_COMMAND='history -a'

Create .bashrc and add there 

    alias bprj_with_spec_env='export HOME=/c/Workspace/YourProjects/project_name_with_spec_env/; bash'

    alias prj_your_project_name_='cd /c/Workspace/YourProjects/project_name'
    alias prj_your_project_name_validation='cd /c/Workspace/YourProjects/project_name/validation'

The advantage of bashrc is the precise control of your OS environment. You can overwrite default OS env by exporting them during bashrc init or by calling functions.

    printWinEnv() {
        echo "JAVA_HOME: "$JAVA_HOME
    }

    path-add() {
        pathElement=$1
        if [ ! -d "$pathElement" ];then
            echo "Path $pathElement does not exist!"
        else
            if [[ ${PATH} != *"$pathElement"* ]];then
                export PATH=$pathElement:$PATH
            else
                :
            fi
        fi
    }

    path-remove() {
        pathElement=$1
        if [ ! -d "$pathElement" ];then
            echo "Path $pathElement does not exist!"
        else
            if [[ ${PATH} == *"$pathElement"* ]];then
                export PATH=`echo $PATH | tr ":" "\n" | grep -v $pathElement | tr "\n" ":"`
            else
                :
            fi
        fi
    }

    useJava() {
        if [ "$#" -ne 1 ]; then
            echo "Expected 1 parameter: java path"
        else
            path-remove $JAVA_HOME
            export JAVA_HOME=$1
            path-add "$JAVA_HOME/bin"
        fi
    }

    useJava8() {
        echo "Setting up Java 1.8"
        useJava "/c/MyProgramFiles/Java/jdk1.8.0_291"
        printWinEnv
    }

    useJava11() {
        echo "Setting up Java 11"
        useJava "/c/MyProgramFiles/Java/jdk-11"
        printWinEnv
    }

    ...

    useJava11

In case you want to have specific configuration just for your project then it is better to prepare new .bashrc file inside your project folder.

    echo "Your specific project setup"
    source /c/Users/Username/.bashrc

    useJava8

    cd ~

You can enter this project by typing bprj_with_spec_env in a terminal.

## Tools

The best code editors are [Eclipse](https://www.eclipse.org/downloads/packages), [IntelliJ IDEA](https://www.jetbrains.com/idea), [Visual Studio Code](https://code.visualstudio.com), [Spring Tool Suite](https://spring.io/tools).

## Notes

The best way to store notes is to use Markdown text format and version it with Git.

[Gollum](https://github.com/gollum/gollum) - GitHub based UI for Markdown

[Hugo](https://github.com/gohugoio/hugo) - K8s based UI for Markdown

[Freeplane](https://www.freeplane.org/wiki/index.php/Home) - Mind mapper

## Developer roadmaps

There are nice roadmaps in case you want to be a skillful engineer - [roadmap.sh](https://roadmap.sh/roadmaps).

Good luck and have fun ðŸ˜„ 
